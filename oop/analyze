#!/bin/bash

#SUB
warts2link(){
test $# -lt 1 && echo 'warts2link $prefix.warts[.tar.gz;.gz]' && exit

input_file_path=$1
prefix=$(echo $input_file_path | sed 's/\.gz$//' | sed 's/\.tar$//' | sed 's/\.warts$//')

(test ! -z "$(echo $input_file_path | grep -E '\.tar\.gz$')" && tar zxf $input_file_path -O \
  || test ! -z "$(echo $input_file_path | grep -E '\.gz$')" && gzip -cd $input_file_path \
  || cat $input_file_path) | (test ! -z "$(echo $input_file_path | grep -E 'warts')" && sc_warts2text \
  || cat) | perl trace2link.pl -p $prefix -
#output_file_path: $prefix.links
}

link2iface(){
test $# -lt 1 && echo 'link2iface $prefix.links' && exit

input=$1
prefix=$(echo $input | sed 's/\.links$//')

cat $input | python <(
cat << "END"
out={}
while True:
  try:
    line=raw_input()
  except:
    break
  fields = line.split()
  print fields[0] # 'from' must be a router iface
  if not out.has_key(fields[1]):
    out[fields[1]] = fields[2]
  elif fields[2] == "N":
    out[fields[1]] = "N"
for k,v in out.items():
  if v == "N":
    print k
END
) | sort | uniq >$prefix.ifaces
#output_file_path: $prefix.ifaces
}

link_coll(){
test $# -lt 2 && echo 'collapse $aliases $prefix.links' && exit

aliases=$1
links=$2
prefix=$(echo $links | sed 's/\.links$//')

./collapse.sh $aliases $links >$prefix.rtrlinks
#output_file_path: $prefix.rtrlinks
}

warts2ifaces(){
test $# -lt 1 && echo 'warts2ifaces $input $output' && exit

input=$1
output=$2
prefix=$(echo $output | sed 's/\.ifaces$//')
for l in ${input[*]}; do
  pfx=$(echo $l | sed 's/\.warts$//')
  warts2link $l
  echo $pfx.links
done | perl linkmerge.pl >$prefix.links
link2iface $prefix.links
}

pchar2link(){
test $# -lt 1 && echo 'pchar2link $pchar' && exit

pchar=$1
prefix=$(echo $pchar | sed 's/\.pchar$//')
cat $pchar | python <(
cat << "EOF"
import re

d = {}
def add():
  # print 'pchar to %s' % (dst)
  p = hl[0]
  for h in hl[1:]:
    if 'bw' in h:
      # print '%d %s %d %s %f' % (p['n'], p['ip'], h['n'],h['ip'],h['bw'])
      k = (p['ip'], h['ip']);
      if "*" in k:
        continue
      if not k in d or d[k] > h['bw']:
        d[k] = h['bw']
      p = h

hl = []; h = {}; dst = ''
while True:
  try:
    l = raw_input().strip()
  except:
    add()
    break
  # new pchar
  if l.startswith('pchar to'):
    dst = l.split()[2]
    if hl:
      hl.append(h); h ={}
      add()
      hl = []
    continue

  # new hop
  r = re.search(r'^(\d+): (\S*)', l)
  if r:
    if h:
      hl.append(h); h = {}
    n, ip = r.group(1), r.group(2)
    h['n'] = int(n)
    h['ip'] = '*' if ip == 'no' else ip
    continue

  # hop char
  if l.startswith('Hop char:'):
    r = re.search(r'bw = (\S*) Kbps', l)
    if r:
      bw = r.group(1)
      h['bw'] = 0 if '-' in bw else float(bw)

# output
for k,v in d.items():
  print '%s %s %.2f' % (k[0], k[1], v)
EOF
) >$prefix.links
}

pchars2link(){
test $# -lt 1 && echo 'pchars2link $input $output' && exit

input=$1
output=$2
for l in ${input[*]}; do
  pfx=$(echo $l | sed 's/\.pchar$//')
  pchar2link $l
  echo $pfx.links
done \
| xargs -n 1 cat | \
python <(
    cat << "EOF"
d = {}
while True:
  try:
    l = raw_input().strip()
  except:
    break
  f = l.split()
  k = (f[0], f[1])
  if not k in d or float(d[k]) < float(f[2]):
    d[k] = f[2]

# output
for k,v in d.items():
  print ' '.join(k+(v,))
EOF
) >$output
}

mrinfos2link(){
test $# -lt 1 && echo 'mrinfos2link $input $output' && exit

input=$1
output=$2
prefix=$(echo $output | sed 's/\.links$//')
pl=($(for l in ${input[*]}; do
  pfx=$(echo $l | sed 's/\.mrinfo$//')
  mrinfo2link $l
  echo $pfx
done))

# link
for l in ${pl[*]}; do
  cat $l.links
done | \
python <(
cat << "EOF"
d = {}
while True:
  try:
    l = raw_input().strip()
  except:
    break
  f = l.split()
  k = (f[0], f[1])
  d[k] = ''

# output
for k in d.keys():
  print ' '.join(k)
EOF
) >$output

# aliases
for l in ${pl[*]}; do
  cat $l.aliases
done | \
python <(
cat << "EOF"
#sub
def find(x):
  if not sets.has_key(x):
    sets[x] = [x,0]
    return x

  if sets[x][0] == x:
    return x
  else:
    return find(sets[x][0])

def union(x,y):
  rx = find(x)
  ry = find(y)
  if rx == ry:
    return
  if sets[rx][1] < sets[ry][1]:
    sets[rx][0] = ry
  elif sets[rx][1] > sets[ry][1]:
    sets[ry][0] = rx
  else:
    sets[ry][0] = rx
    sets[rx][1] += 1

sets={}
while True:
  try:
    l = raw_input().strip()
  except:
    break
  f = l.split()
  union(f[0], f[1])

# output rtrnodes
d={}
for k in sets.keys():
  r=find(k)
  if not d.has_key(r):
    d[r] = [k]
  else:
    d[r].append(k)

for v in d.values():
  print ' '.join(sorted(v))
EOF
) >$prefix.rtrnodes
}

mrinfo2link(){
test $# -lt 1 && echo 'mrinfo2link $mrinfo' && exit

mrinfo=$1
prefix=$(echo $mrinfo | sed 's/\.mrinfo$//')
cat $mrinfo | python <(
cat << "EOF"
EOF
)

cat $mrinfo | python <(
cat << "EOF"
import re
import sys

prefix = sys.argv[1]

from struct import unpack
from socket import AF_INET, inet_pton, inet_aton
def private(ip):
  f = unpack('!I',inet_pton(AF_INET,ip))[0]
  nl = (["0.0.0.0","255.255.255.255"], ["127.0.0.0","255.0.0.0"],["192.168.0.0","255.255.0.0"],["172.16.0.0","255.240.0.0"],["10.0.0.0","255.0.0.0"])
  for net in nl:
    mask = unpack('!I',inet_aton(net[1]))[0]
    p = unpack('!I',inet_aton(net[0]))[0]
    if (f & mask) == p:
      return True
  return False

sets = {}; d = {}; dst = ''
f = open(prefix+'.aliases', 'w')
while True:
  try:
    l = raw_input().strip()
  except:
    break
  # new mrinfo
  if l.startswith('mrinfo to'):
    dst = l.split()[2]
    continue

  r = re.search(r'^mrinfo: got reply from (\S+)', l)
  if r:
    dst = r.group(1)
    continue

  r = re.search(r'^(\S+) -> (\S+) ', l)
  if r:
    rip, nip = r.groups()
    if private(rip) or private(nip):
      continue
    if dst and rip != dst:
      f.write( '%s %s\n' % (dst, rip) )
    if rip != nip:
      k = (rip, nip)
      if not k in d:
        d[k] = ''

# output links
with open(prefix+'.links', 'w') as f:
  for k in d.keys():
    f.write('%s %s\n' %(k[0], k[1]))
EOF
) $prefix
}

#MAIN
usage(){
echo 'analyze <$command> [$args]'
echo 'COMMANDS:'
echo '  warts2link'
echo '  link2iface'
echo '  link_coll'
}
test $# -lt 1 && usage && exit

cmd=$1
case $cmd in
  "warts2link")
    test $# -lt 2 && usage && exit
    input_file_path=$2;

    warts2link $input_file_path
    prefix=$(echo $input_file_path | sed 's/\.gz$//' | sed 's/\.tar$//' | sed 's/\.warts$//')
    ;;
  "link2iface")
    test $# -lt 2 && usage && exit
    input=$2;

    link2iface $input
    ;;
  "link_coll")
    test $# -lt 3 && usage && exit
    aliases=$2; links=$3;

    link_coll $aliases $links
    ;;
  "warts2iface")
    test $# -lt 3 && usage && exit

    input=$2
    output=$3
    warts2ifaces "$input" $output
    ;;
  "pchars2link")
    test $# -lt 3 && usage && exit

    input=$2
    output=$3
    pchars2link "$input" $output
    ;;
  "mrinfos2link")
    test $# -lt 3 && usage && exit

    input=$2
    output=$3
    mrinfos2link "$input" $output
    ;;
  *)
    usage
    exit;;
esac
